#!/usr/bin/env node
/* Generate src/_types/Services.luau and src/_types/Controllers.luau
   from discovered modules in the repo (plus optional place overrides).
*/
const fs = require("fs");
const path = require("path");

const PLACE = process.argv[2]; // optional: so we can include place_overrides/<Place>

const REPO = path.join(__dirname, "..");
const SRC  = path.join(REPO, "src");
const TYPES_DIR = path.join(SRC, "_types");

const OUT_SERVICES    = path.join(TYPES_DIR, "Services.luau");
const OUT_CONTROLLERS = path.join(TYPES_DIR, "Controllers.luau");

const SYS_ROOT = path.join(SRC, "_systems");
const OV_BASE  = PLACE ? path.join(REPO, "place_overrides", PLACE) : null;

// ---------- fs helpers ----------
const LU = (n) => /\.lua(u)?$/i.test(n);
const exists = (p) => fs.existsSync(p);
const isDir  = (p) => exists(p) && fs.statSync(p).isDirectory();
const isFile = (p) => exists(p) && fs.statSync(p).isFile();
const stripExt = (n) => n.replace(/\.(luau|lua)$/i, "");
function hasInit(dir) {
  return isFile(path.join(dir, "init.luau")) || isFile(path.join(dir, "init.lua"));
}

// ---------- collectors ----------
/** Collect direct module names (files or folder-backed) from a single registry directory */
function collectModulesFromRegistryDir(regDir) {
  if (!isDir(regDir)) return [];
  const out = [];
  for (const entry of fs.readdirSync(regDir, { withFileTypes: true })) {
    const full = path.join(regDir, entry.name);
    if (entry.isDirectory()) {
      if (hasInit(full)) out.push(path.basename(full));
    } else if (entry.isFile() && LU(entry.name)) {
      const base = stripExt(entry.name);
      if (base.toLowerCase() !== "init") out.push(base);
    }
  }
  return out;
}

// ----- Services -----
function collectBaseServices() {
  return collectModulesFromRegistryDir(path.join(SRC, "server", "services"));
}
function collectSystemServices() {
  if (!isDir(SYS_ROOT)) return [];
  const names = new Set();
  for (const sys of fs.readdirSync(SYS_ROOT)) {
    const sdir = path.join(SYS_ROOT, sys, "server", "services");
    collectModulesFromRegistryDir(sdir).forEach(n => names.add(n));
  }
  return [...names];
}
function collectOverrideServices() {
  if (!OV_BASE || !isDir(OV_BASE)) return [];
  const names = new Set();

  // place_overrides/<Place>/server/services
  collectModulesFromRegistryDir(path.join(OV_BASE, "server", "services"))
    .forEach(n => names.add(n));

  // place_overrides/<Place>/_systems/*/server/services
  const oSysRoot = path.join(OV_BASE, "_systems");
  if (isDir(oSysRoot)) {
    for (const sys of fs.readdirSync(oSysRoot)) {
      collectModulesFromRegistryDir(path.join(oSysRoot, sys, "server", "services"))
        .forEach(n => names.add(n));
    }
  }
  return [...names];
}

// ----- Controllers -----
function collectBaseControllers() {
  return collectModulesFromRegistryDir(path.join(SRC, "client", "controllers"));
}
function collectSystemControllers() {
  if (!isDir(SYS_ROOT)) return [];
  const names = new Set();
  for (const sys of fs.readdirSync(SYS_ROOT)) {
    const cdir = path.join(SYS_ROOT, sys, "client", "controllers");
    collectModulesFromRegistryDir(cdir).forEach(n => names.add(n));
  }
  return [...names];
}
function collectOverrideControllers() {
  if (!OV_BASE || !isDir(OV_BASE)) return [];
  const names = new Set();

  // place_overrides/<Place>/client/controllers
  collectModulesFromRegistryDir(path.join(OV_BASE, "client", "controllers"))
    .forEach(n => names.add(n));

  // place_overrides/<Place>/_systems/*/client/controllers
  const oSysRoot = path.join(OV_BASE, "_systems");
  if (isDir(oSysRoot)) {
    for (const sys of fs.readdirSync(oSysRoot)) {
      collectModulesFromRegistryDir(path.join(oSysRoot, sys, "client", "controllers"))
        .forEach(n => names.add(n));
    }
  }
  return [...names];
}

// ---------- generators ----------
function renderServicesLuau(names) {
  const header = `--!strict
-- Auto-generated by tools/genTypes.js — DO NOT EDIT
-- Regenerate via: npx woolly gen  (or run the script directly)

local ServerScriptService = game:GetService("ServerScriptService")

`;
  const body = names.sort().map(n =>
    `export type ${n} = typeof(require(ServerScriptService.Server.Services.${n}))`
  ).join("\n");

  const registry = `
export type Registry = {
${names.sort().map(n => `\t${n}: ${n},`).join("\n")}
\t[string]: any,
}

return {}
`;
  return header + body + "\n" + registry;
}

function renderControllersLuau(names) {
  const header = `--!strict
-- Auto-generated by tools/genTypes.js — DO NOT EDIT
-- Regenerate via: npx woolly gen  (or run the script directly)

local StarterPlayer = game:GetService("StarterPlayer")

`;
  // We reference the final runtime mount:
  // StarterPlayer.StarterPlayerScripts.Client.Controllers.<Name>
  const body = names.sort().map(n =>
    `export type ${n} = typeof(require(StarterPlayer.StarterPlayerScripts.Client.Controllers.${n}))`
  ).join("\n");

  const registry = `
export type Registry = {
${names.sort().map(n => `\t${n}: ${n},`).join("\n")}
\t[string]: any,
}

return {}
`;
  return header + body + "\n" + registry;
}

// ---------- main ----------
(function main() {
  // Services
  const services = [
    ...collectBaseServices(),
    ...collectSystemServices(),
    ...collectOverrideServices(),
  ];
  const allServices = [...new Set(services)];

  // Controllers
  const controllers = [
    ...collectBaseControllers(),
    ...collectSystemControllers(),
    ...collectOverrideControllers(),
  ];
  const allControllers = [...new Set(controllers)];

  if (!isDir(TYPES_DIR)) fs.mkdirSync(TYPES_DIR, { recursive: true });

  fs.writeFileSync(OUT_SERVICES, renderServicesLuau(allServices), "utf8");
  console.log("✓ Wrote", path.relative(process.cwd(), OUT_SERVICES), `(${allServices.length} services)`);

  fs.writeFileSync(OUT_CONTROLLERS, renderControllersLuau(allControllers), "utf8");
  console.log("✓ Wrote", path.relative(process.cwd(), OUT_CONTROLLERS), `(${allControllers.length} controllers)`);
})();